#!/bin/bash

APP="{{ atl_product_family }}"

s3_backup_url_raw=$1
if test -z "$s3_backup_url_raw"; then
       cat << EOF
Usage: $0 s3_backup_url

Restore database and home directory for app "$APP".
s3_backup_url should contain files
- VERSION       Version of app
- home.zst      App home tar archive
- plugins.json  App plugin information
- database/     Backup as created by mysqlsh

THE APPLICATION MUST BE STOPPED BEFORE RESTORE!
EOF
exit 1
fi

# Lop off last char if it's /
s3_backup_url=$(echo $s3_backup_url_raw | sed -e 's/^\(.*\)\/$/\1/')

if systemctl is-active --quiet $APP; then
    echo "Service \"$APP\" is running; must be stopped before restore."
    exit 1
fi

if ! aws s3 ls "${s3_backup_url}/home.zst" > /dev/null 2>&1; then
    echo "s3_backup_url doesn't have home tar archive"
    exit 1
fi

if ! aws s3 ls "${s3_backup_url}/database" > /dev/null 2>&1; then
    echo "s3_backup_url doesn't have database"
    exit 1
fi

backup_version=$(aws s3 cp "${s3_backup_url}/VERSION" -)
if test -z $backup_version; then
    echo "s3_backup_url doesn't have VERSION file; continuing anyway"
else
    current_version=$(basename $(readlink -f /opt/atlassian/*/current))
    if [ "$backup_version" != "$current_version" ]; then
	echo "Current app version is \"$current_version\", backup version is \"$backup_version\"; can't clone"
	exit 1
    fi
fi

# /var/tmp is bigger
export TEMPDIR=$(mktemp -p /var/tmp -d)

##############################################
# Restore home directory
##############################################
echo "Restoring home directory from site backup"
rm -rf "{{ atl_product_home }}/*" "{{ atl_product_home }}/.*"
aws s3 cp "${s3_backup_url}/home.zst" - | tar -C "{{ atl_product_home }}" --zstd -xf -
chown -R {{ atl_product_user }}:{{ atl_product_user }} {{ atl_product_home }}

# sync directory
# s5cmd sync --delete "${s3_backup_url}/home/*" "{{ atl_product_home }}/"


##############################################
# Restore database
##############################################
echo "Restoring database from site backup"

mycnf=$(/usr/local/bin/create_mycnf.sh)

# Parse s3_backup_url
bucketname=$(echo $s3_backup_url | cut -d '/' -f3)
prefix="$(echo $s3_backup_url | cut -d '/' -f4-)/database"

# Whatever version of the AWS API that mysqlsh is using, it needs
# credentials in env vars instead of the instance role
aws_env_vars=$(/usr/local/bin/aws_env_credentials_from_instance_role.sh)
source $aws_env_vars
rm $aws_env_vars

# Restore backup database over existing database
/usr/local/bin/drop_all_tables.sh
mysqlsh_cmd="${TEMPDIR}/mysqlsh_cmd"
cat << EOF >$mysqlsh_cmd
util.loadDump(
  "$prefix",
  {
    schema: "{{ atl_jdbc_db_name }}",
    s3BucketName: "$bucketname",
    progressFile: "",
    resetProgress: "true"     
  }
)
EOF
mysqlsh --defaults-file=$mycnf --javascript --file=$mysqlsh_cmd

rm -rf $TEMPDIR
rm $mycnf

