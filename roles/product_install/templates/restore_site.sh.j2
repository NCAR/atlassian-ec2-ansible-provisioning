#!/bin/bash

usage () {
    cat << EOF
Usage: $0 [--raw|--clone|--refresh] s3_backup_url

Restore cloned database and home directory for app "$APP";

Modes:
--raw      Restore exact copy
--clone	   Provision a new clone, retaining only database config and site name
--refresh  Refresh a clone, preserving IDP config, passwords etc


s3_backup_url should contain files
- VERSION       Version of app
- home.zst      App home tar archive
- plugins.json  App plugin information
- database/     Backup as created by mysqlsh

The application must be stopped. For clone and refresh, the
install_upm_plugins.sh script must be run to install plugins.

EOF
exit 1
}


APP="{{ atl_product_family }}"

if [ $# -ne 2 ]; then
    usage
fi

clone_mode=$(echo $1 | tr -d '-')
if ! echo "$clone_mode" | grep -Pq "^(raw|clone|refresh)$"; then
    usage
fi

s3_backup_url_raw=$2


# Lop off last char if it's /
s3_backup_url=$(echo $s3_backup_url_raw | sed -e 's/^\(.*\)\/$/\1/')

if systemctl is-active --quiet $APP; then
    echo "Service \"$APP\" is running; must be stopped before restore."
    exit 1
fi

if ! aws s3 ls "${s3_backup_url}/home.zst" > /dev/null 2>&1; then
    echo "s3_backup_url doesn't have home tar archive"
    exit 1
fi

if ! aws s3 ls "${s3_backup_url}/database" > /dev/null 2>&1; then
    echo "s3_backup_url doesn't have database"
    exit 1
fi

if ! aws s3 ls "${s3_backup_url}/plugins.json" > /dev/null 2>&1; then
    echo "s3_backup_url doesn't have plugins list"
    exit 1
fi

backup_version=$(aws s3 cp "${s3_backup_url}/VERSION" -)
if test -z $backup_version; then
    echo "s3_backup_url doesn't have VERSION file"
    exit 1
else
    current_version=$(basename $(readlink -f /opt/atlassian/*/current))
    if [ "$backup_version" != "$current_version" ]; then
	echo "Current app version is \"$current_version\", backup version is \"$backup_version\"; can't restore"
	exit 1
    fi
fi

mkdir -p /var/atlassian/application-data/tmp > /dev/null 2>&1
export TEMPDIR=$(mktemp -p /var/atlassian/application-data/tmp -d)

# Whatever version of the AWS API that mysqlsh is using, it needs
# credentials in env vars instead of the instance role
aws_env_vars=$(/usr/local/bin/aws_env_credentials_from_instance_role.sh)
source $aws_env_vars
rm $aws_env_vars

##############################################
# Restore home directory
##############################################
echo ">> Restoring home directory from clone backup"

# Tar up local retained files
# Filenames are for find command
retained_files="${TEMPDIR}/retained_files_list"
retained_files_tar="${TEMPDIR}/retained_files.zst"
if [ "$clone_mode" != "raw" ]; then
    for pattern in $(yq -r ".${clone_mode}.filesystem.retained[]" /var/clone_config.yaml); do
	(cd {{ atl_product_home }}; find . -type f -wholename "$pattern" >> $retained_files)
    done

    if test -e $retained_files; then
	echo ">>> Retaining files: "
	cat $retained_files
	tar -C {{ atl_product_home }} --files-from=$retained_files --zstd -cf $retained_files_tar
    fi
fi

# Restore home directory
echo ">>> Deleting contents of home directory"
rm -rf {{ atl_product_home }}/* {{ atl_product_home }}/.*

echo ">>> Restoring home directory from backup"
aws s3 cp "${s3_backup_url}/home.zst" - | tar -C "{{ atl_product_home }}" --zstd -xf -

# untar retained over sync'd directory
if test -e $retained_files_tar; then
    tar -C {{ atl_product_home }} --zstd -xf $retained_files_tar
    chown -R {{ atl_product_user }}:{{ atl_product_user }} {{ atl_product_home }}
fi
    
##############################################
# Restore database
##############################################
if [ "$clone_mode" != "raw" ]; then

    # Reset baseurl at the the end
    dest_baseurl="$(/usr/local/bin/get_baseurl.sh)"
    dest_site="$(echo $dest_baseurl | awk -F/ '{print $3}')"
    
    # Save stuff we need from the database.  We do this by creating dumps
    # for these by passing queries to mysqldump
    mycnf=$(/usr/local/bin/create_mycnf.sh)
    mysql_to_restore="${TEMPDIR}/mysql_to_restore"
    mkdir $mysql_to_restore

    # Generate list of full tables to retain
    full_tables="${TEMPDIR}/full_tables"
    for raw_table in $(yq -r ".${clone_mode}.database.retained.tables[]" /var/clone_config.yaml); do
	if echo $raw_table | grep -Fq '%'; then
	    mysql --defaults-file=$mycnf -sN -e "show tables like '${raw_table}';" >> $full_tables
	else
	    echo $raw_table >> $full_tables
	fi
    done

    if test -s $full_tables; then 
	for table in $(cat $full_tables); do
	    echo ">>> Dumping full table $table"
	    mkdir -p "${mysql_to_restore}/${table}" >/dev/null 2>&1
	    mysqldump --defaults-file=$mycnf \
		      --add-drop-table \
		      --create-options \
		      --disable-keys \
		      --set-gtid-purged=OFF \
		      {{ atl_jdbc_db_name }} $table > $(mktemp -p "${mysql_to_restore}/${table}")
	done
    fi

    # Queries
    queried_tables=$(yq -r ".${clone_mode}.database.retained.queries | keys[]" /var/clone_config.yaml)
    for table in $queried_tables; do
	echo ">>> Dumping query for table $table"    
	mkdir -p "${mysql_to_restore}/${table}" >/dev/null 2>&1
	while IFS="" read -r query|| [ -n "$query" ]; do
	    mysqldump --defaults-file=$mycnf \
		      --disable-keys \
                      --no-create-info \
                      --no-tablespaces \
                      --replace \
                      --set-gtid-purged=OFF \
                      --single-transaction \
                      --skip-triggers \
		      --where="$query" \
		      {{ atl_jdbc_db_name }} $table > $(mktemp -p "${mysql_to_restore}/${table}")
	done < <(yq -r ".${clone_mode}.database.retained.queries.${table}[]" /var/clone_config.yaml)
    done
    
fi

# Parse s3_backup_url
bucketname=$(echo $s3_backup_url | cut -d '/' -f3)
prefix="$(echo $s3_backup_url | cut -d '/' -f4-)/database"

# Restore clone database over existing database
echo ">> Restoring database from clone backup"
echo ">>> Dropping all tables"
/usr/local/bin/drop_all_tables.sh

mysqlsh_cmd="${TEMPDIR}/mysqlsh_cmd"
cat << EOF >$mysqlsh_cmd
util.loadDump(
  "$prefix",
  {
    schema: "{{ atl_jdbc_db_name }}",
    s3BucketName: "$bucketname",
    progressFile: "",
    resetProgress: "true",
    threads: 8
  }
)
EOF
echo ">>> Performing restore"
mysqlsh --defaults-file=$mycnf --javascript --file=$mysqlsh_cmd

# Generate list of tables for literal string substitutions
if [ "$clone_mode" != "raw" ]; then
    edit_tables="${TEMPDIR}/edit_tables"
    touch $edit_tables
    for raw_table in $(yq -r ".${clone_mode}.database.substitutions.tables[]" /var/clone_config.yaml); do
	if echo $raw_table | grep -Fq '%'; then
	    mysql --defaults-file=$mycnf -sN -e "show tables like '${raw_table}';" >> $edit_tables
	else
	    echo $raw_table >> $edit_tables
	fi
    done

    src_baseurl="$(/usr/local/bin/get_baseurl.sh)"
    src_site="$(echo $src_baseurl | awk -F/ '{print $3}')"

    # Dump table, replace strings
    for table in $(cat $edit_tables); do
	echo ">>> Replacing strings in table $table"
	mkdir -p "${mysql_to_restore}/${table}" >/dev/null 2>&1
	tablesql=$(mktemp -p "${mysql_to_restore}/${table}")
	mysqldump --defaults-file=$mycnf \
		  --disable-keys \
		  --no-create-info \
		  --no-tablespaces \
		  --replace \
		  --set-gtid-purged=OFF \
		  --single-transaction \
		  --skip-triggers \
		  {{ atl_jdbc_db_name }} $table > $tablesql

	# Replace base url, then replace site
	perl -s -p -i -e 's/\Q$src\E/$dst/g' -- -src=$src_baseurl -dst=$dest_baseurl $tablesql
	perl -s -p -i -e 's/\Q$src\E/$dst/g' -- -src=$src_site -dst=$dest_site $tablesql
	
	for subst_str in $(yq -r ".${clone_mode}.database.substitutions.strings[]" /var/clone_config.yaml); do
	    # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
	    subst_val=$(yq -r ".${clone_mode}.database.substitutions.strings.\"${subst_str}\"" /var/clone_config.yaml)
	    perl -s -p -i -e 's/\Q$src\E/$dst/g' -- -src=$subst_str -dst=$subst_val $tablesql
	done
	
	if ! test -s $tablesql; then
	    rm $tablesql
	fi
    done

    #
    # Restore edited and retained data for database
    #
    # WARNING the order is undetermined, so dumpfile must not step on each
    # other's toes
    for table in $(ls $mysql_to_restore); do
	for f in $(ls "${mysql_to_restore}/${table}"); do
	    echo ">>> Restoring retained data for table $table"
            dump="${mysql_to_restore}/${table}/${f}"
            mysql --defaults-file=$mycnf {{ atl_jdbc_db_name }} < $dump
	done
    done

    echo ">>> Resetting baseurl"
    /usr/local/bin/set_baseurl.sh $dest_baseurl
fi

if aws s3 ls "${s3_backup_url}/plugins.json" > /dev/null 2>&1; then
    echo ">>> Copying plugins file to /tmp/plugins.json"
    aws s3 cp "${s3_backup_url}/plugins.json" /tmp/plugins.json

    echo
    cat <<PLUGINS_MSG

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To install plugins:
- Run "toggle_upm_rest.sh on"
- Start the application
- Create a REST API token as an admin user in the GUI
- Export the token in the shell: "export ATL_REST_TOKEN='MY_REST_TOKEN'"
- Run install_upm_plugins.sh
- Check that all plugins have been installed
- Shut down tha app
- Run "toggle_upm_rest.sh off"
- Start the app
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
PLUGINS_MSG
else
    echo ">>> Plugin list is not available; plugins will need to be installed by hand"
fi

##############################################
# Postprocess
# Run app-specific post-process script if it exists
##############################################
test -e /usr/local/bin/clone_postprocess && /usr/local/bin/clone_postprocess

rm -rf $TEMPDIR
